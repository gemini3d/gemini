submodule (io) plasma_input

use h5fortran, only : hdf5_file, HSIZE_T
use timeutils, only : date_filename
use reader, only : get_simsize3
use sanity_check, only : check_finite_current, check_finite_plasma
use interpolation, only : interp3
use grid, only : get_grid3_coords_hdf5

implicit none (type, external)

contains


module procedure input_plasma_currents
! module subroutine input_plasma_currents(outdir,flagoutput,ymd,UTsec,J1,J2,J3)
!! READS, AS INPUT, A FILE GENERATED BY THE GEMINI.F90 PROGRAM.

character(:), allocatable :: filenamefull

type(hdf5_file) :: hf

integer, dimension(3) :: i0, i1
integer, dimension(2) :: ix2, ix3
!! HDF5-MPI partitioning


ix2 = [mpi_cfg%myid*lx2+1, (mpi_cfg%myid+1)*lx2]
ix3 = [mpi_cfg%myid*lx3+1, (mpi_cfg%myid+1)*lx3]
if(lx2 == 1) then
  ix2 = [1, 1]
elseif(lx3 == 1) then
  ix3 = [1, 1]
endif

i0 = [1, ix2(1), ix3(1)]
i1 = [lx1, ix2(2), ix3(2)]

!>  CHECK TO MAKE SURE WE ACTUALLY HAVE THE DATA WE NEED TO DO THE MAG COMPUTATIONS.
if (flagoutput==3) then
  error stop 'ERROR:gemini3d:input_root_currents: Need current densities in the output to compute magnetic fields'
endif

!> FORM THE INPUT FILE NAME
filenamefull = date_filename(outdir, ymd, UTsec) // '.h5'
if (mpi_cfg%myid == 0) print *, 'Input file name for current densities:  ', filenamefull

call hf%open(filenamefull, action='r', mpi=.true.)

call hf%read('/J1all', J1(1:lx1, 1:lx2, 1:lx3), istart=i0, iend=i1)
call hf%read('/J2all', J2(1:lx1, 1:lx2, 1:lx3), istart=i0, iend=i1)
call hf%read('/J3all', J3(1:lx1, 1:lx2, 1:lx3), istart=i0, iend=i1)

if (mpi_cfg%myid == 0) then
print *, 'Min/max current data:  ',minval(J1(1:lx1, 1:lx2, 1:lx3)),maxval(J1(1:lx1, 1:lx2, 1:lx3)), &
                                    minval(J2(1:lx1, 1:lx2, 1:lx3)),maxval(J2(1:lx1, 1:lx2, 1:lx3)), &
                                    minval(J3(1:lx1, 1:lx2, 1:lx3)),maxval(J3(1:lx1, 1:lx2, 1:lx3))
endif

call hf%close()


if (mpi_cfg%myid==0) call check_finite_current(outdir, J1, J2, J3)

end procedure input_plasma_currents


module procedure input_plasma
! subroutine input_plasma(x1,x2,x3all,indatsize,indatfile, ns,vs1,Ts)
!! A BASIC WRAPPER FOR THE ROOT AND WORKER INPUT FUNCTIONS
!! BOTH ROOT AND WORKERS CALL THIS PROCEDURE SO UNALLOCATED
!! VARIABLES MUST BE DECLARED AS ALLOCATABLE, INTENT(INOUT)

!! READ INPUT FROM FILE AND DISTRIBUTE TO WORKERS.
!! STATE VARS ARE EXPECTED INCLUDE GHOST CELLS.

!> zero initialize to avoid having garbage in ghost cells
ns = 0
vs1 = 0
Ts = 0

!> read in the full initial conditions files

call get_initial_cond(indatsize, indatfile, ns, vs1, Ts, Phiall)


if (mpi_cfg%myid==0) then

  !> USER SUPPLIED FUNCTION TO TAKE A REFERENCE PROFILE AND CREATE INITIAL CONDITIONS FOR ENTIRE GRID.
  !> ASSUMING THAT THE INPUT DATA ARE EXACTLY THE CORRECT SIZE (AS IS THE CASE WITH FILE INPUT) THIS IS NOW SUPERFLUOUS
  print '(/,A,/,A)', 'Initial conditions (root):','------------------------'
  print '(A,2ES11.2)', 'Min/max input density:',     minval(ns(1:lx1,1:lx2,1:lx3,7)),  maxval(ns(1:lx1,1:lx2,1:lx3,7))
  print '(A,2ES11.2)', 'Min/max input velocity:',    minval(vs1(1:lx1,1:lx2,1:lx3,1:lsp)), maxval(vs1(1:lx1,1:lx2,1:lx3,1:lsp))
  print '(A,2ES11.2)', 'Min/max input temperature:', minval(Ts(1:lx1,1:lx2,1:lx3,1:lsp)),  maxval(Ts(1:lx1,1:lx2,1:lx3,1:lsp))
  print '(A,2ES11.2)', 'Min/max input electric potential:', minval(Phi(1:lx1,1:lx2,1:lx3)),  maxval(Phi(1:lx1,1:lx2,1:lx3))
  print '(A,2ES11.2)', 'Min/max input electric potential (full grid):', minval(Phiall(1:lx1,1:lx2all,1:lx3all)),  &
                        maxval(Phiall(1:lx1,1:lx2all,1:lx3all))

  call check_finite_plasma(out_dir, ns, vs1, Ts)
endif

end procedure input_plasma


subroutine get_initial_cond(indatsize, indatfile, ns, vs1, Ts, Phiall)

character(*), intent(in) :: indatsize, indatfile
real(wp), dimension(-1:,-1:,-1:,:), intent(inout) :: ns, vs1, Ts
real(wp), dimension(-1:,-1:,-1:), intent(inout) :: Phiall

type(hdf5_file) :: hf
integer :: lx1in,lx2in,lx3in
real(wp), dimension(:,:), allocatable :: Phislab
real(wp), allocatable :: tmpPhi(:)

integer, dimension(4) :: i0, i1
!! HDF5-MPI partitioning
! integer(HSIZE_T), allocatable :: dims(:)

i0 = [1, mpi_cfg%myid2 * lx2 + 1, mpi_cfg%myid3 * lx3 + 1, 1]
i1 = [lx1, i0(2) + lx2 - 1, i0(3) + lx3 - 1, lsp]

allocate(Phislab(1:lx2all, 1:lx3all))
!! EFL potential
Phislab = 0

!> READ IN FROM FILE, AS OF CURVILINEAR BRANCH THIS IS NOW THE ONLY INPUT OPTION
call get_simsize3(indatsize, lx1in, lx2in, lx3in)

if (mpi_cfg%myid==0) then
  print '(2A,i0,1x,i0,1x,i0)', indatsize,' input dimensions:',lx1in,lx2in,lx3in
  print '(A,i0,1x,i0,1x,i0)', 'Target (output) grid structure dimensions:',lx1, lx2all, lx3all
endif

if ((lx1/=lx1in .or. lx2all/=lx2in .or. lx3all/=lx3in)) then
  error stop 'ERROR:gemini3d: The input data must be the same size as the grid which you are running the simulation on' // &
        '- use a script to interpolate up/down to the simulation grid'
end if

! print '(a,i0,1x,i0,1x,i0,a,i0,1x,i0,a,i0,1x,i0,a,i0,1x,i0,1x,i0,1x,i0,a,i0,1x,i0,1x,i0,1x,i0)', &
!   "TRACE:get_initial_cond: myid, myid2, myid3: ", &
!   mpi_cfg%myid, mpi_cfg%myid2, mpi_cfg%myid3, &
!   " dx2, dx3: ", dx2, dx3, " lx2, lx3: ", lx2, lx3, &
!   " i0:", i0, " i1:", i1

call hf%open(indatfile, action='r', mpi=.true.)

! if(mpi_cfg%myid==0) then
!   call hf%shape("/nsall", dims)
!   print '(a,i0,1x,i0,1x,i0,1x,i0)', "TRACE:get_initial_cond: nsall dims:", dims
! endif

call hf%read('/nsall',  ns(1:lx1, 1:lx2, 1:lx3, 1:lsp), istart=i0, iend=i1)
call hf%read('/vs1all', vs1(1:lx1, 1:lx2, 1:lx3, 1:lsp), istart=i0, iend=i1)
call hf%read('/Tsall',  Ts(1:lx1, 1:lx2, 1:lx3, 1:lsp), istart=i0, iend=i1)

call hf%close()

if(mpi_cfg%myid /= 0) return

call hf%open(indatfile, action='r', mpi=.false.)

if (hf%exist('/Phiall')) then
  if (hf%ndim('/Phiall') == 1) then
    if (lx2all==1) then
      allocate(tmpPhi(lx3all))
    else
      allocate(tmpPhi(lx2all))
    end if

    call hf%read('/Phiall', tmpPhi)

    if (lx2all==1) then
      Phislab(1,:) = tmpPhi
    else
      Phislab(:,1) = tmpPhi
    end if
  else
    call hf%read('/Phiall', Phislab)
  endif
end if

call hf%close()

!> Apply EFL approx to compute full grid potential
Phiall(1:lx1,1:lx2all,1:lx3all) = spread(Phislab(1:lx2all,1:lx3all), dim=1, ncopies=lx1)

deallocate(Phislab)    ! explicitly get rid of allocated storage

end subroutine get_initial_cond


!> Interpolate initial conditions onto "local" subgrid; we assume that the input data grid is specified
!    by the input file, whereas the target grid *could* be different, e.g. due to refinement or some other
!    custom arrangement.  The entire input file will be read by each worker calling this procedure.
!  Since this is only performing spatial interpolation it is easiest to just use the interpolation module
!    directly rather than create a type extension for inputdata (which inherently wants to also do time interpolation)
!    and then overriding the interp to space-only.
module procedure interp_file2subgrid
  real(wp), dimension(:,:,:,:), allocatable :: nsall,vs1all,Tsall
  real(wp), dimension(:,:,:), allocatable :: Phiall
  real(wp), dimension(:), allocatable :: parmflat
  integer :: lx1,lx2,lx3
  integer :: lx1in,lx2in,lx3in
  real(wp), dimension(:), allocatable :: x1in,x2in,x3in
  real(wp) :: glatctr=0._wp, glonctr=0._wp
  integer :: isp

  ! convenience
  lx1=size(x1)-4; lx2=size(x2)-4; lx3=size(x3)-4;

  ! read in the ICs size and allocate data
  call get_simsize3(out_dir,lx1in,lx2in,lx3in)
  allocate(x1in(-1:lx1in+2),x2in(-1:lx2in+2),x3in(-1:lx3in+2))
  allocate(nsall(-1:lx1in+2,-1:lx2in+2,-1:lx3in+2,1:lsp), &
            vs1all(-1:lx1in+2,-1:lx2in+2,-1:lx3in+2,1:lsp), &
            Tsall(-1:lx1in+2,-1:lx2in+2,-1:lx3in+2,1:lsp), &
            Phiall(-1:lx1in+2,-1:lx2in+2,-1:lx3in+2))
  allocate(parmflat(lx1*lx2*lx3))

  ! get the input grid coordinates
  call get_grid3_coords_hdf5(out_dir,x1in,x2in,x3in,glonctr,glatctr)


  ! we must make sure that the target coordinates do not range outside the input file coordinates
  if(x1(1)<x1in(1) .or. x1(lx1)>x1in(lx1in)) then
    error stop 'interp_file2grid: x1 target coordinates beyond input grid coords'
  end if
  if(x2(1)<x2in(1) .or. x2(lx2)>x2in(lx2in)) then
    error stop 'interp_file2grid: x2 target coordinates beyond input grid coords'
  end if
  if(x3(1)<x3in(1) .or. x3(lx3)>x3in(lx3in)) then
    error stop 'interp_file2grid: x3 target coordinates beyond input grid coords'
  end if

  ! read in the input initial conditions, only hdf5 files are support for this functionality
  call get_initial_cond(indatsize,indatfile,nsall,vs1all,Tsall,Phiall)

  ! interpolation input data to mesh sites; do not interpolate to ghost cells
  do isp=1,lsp
    parmflat=interp3(x1in(1:lx1in),x2in(1:lx2in),x3in(1:lx3in),nsall(1:lx1in,1:lx2in,1:lx3in,isp), &
                       x1(1:lx1),x2(1:lx2),x3(1:lx3))
    ns(1:lx1,1:lx2,1:lx3,isp)=reshape(parmflat,[lx1,lx2,lx3])
    parmflat=interp3(x1in(1:lx1in),x2in(1:lx2in),x3in(1:lx3in),vs1all(1:lx1in,1:lx2in,1:lx3in,isp), &
                       x1(1:lx1),x2(1:lx2),x3(1:lx3))
    vs1(1:lx1,1:lx2,1:lx3,isp)=reshape(parmflat,[lx1,lx2,lx3])
    parmflat=interp3(x1in(1:lx1in),x2in(1:lx2in),x3in(1:lx3in),Tsall(1:lx1in,1:lx2in,1:lx3in,isp), &
                       x1(1:lx1),x2(1:lx2),x3(1:lx3))
    Ts(1:lx1,1:lx2,1:lx3,isp)=reshape(parmflat,[lx1,lx2,lx3])
  end do
  parmflat=interp3(x1in(1:lx1in),x2in(1:lx2in),x3in(1:lx3in),Phiall(1:lx1in,1:lx2in,1:lx3in), &
                     x1(1:lx1),x2(1:lx2),x3(1:lx3))
  Phi(1:lx1,1:lx2,1:lx3)=reshape(parmflat,[lx1,lx2,lx3])

  deallocate(x1in,x2in,x3in,nsall,vs1all,Tsall,Phiall,parmflat)
end procedure interp_file2subgrid


end submodule plasma_input
